## 线性表

### 1. 如何判断一个链表有环

#### 题目

[LeetCode 141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

#### 思路 1

通过 Python 字典，遍历链表并用字典记录每个节点，若遍历到某一节点时，其先前已被遍历到，则说明有环。

#### 代码：

```Python
class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        m = {}
        while head:
            # 检查之前是否已被遍历到
            if m.get(head):
                return True
            # 若没有，则存入字典，表示该节点此次被遍历
            m[head] = 1
            head = head.next
        return False
```

#### 思路 2

**快慢指针**，首先创建两个指针 slow(p1) 和 fast(p2)，同时指向这个链表的头节点。然后开始一个大循环，在循环体中，让指针 slow 每次向下移动一个节点，让指针 fast 每次向下移动两个节点，然后比较两个指针指向的节点是否相同。如果相同，则判断出链表有环，如果不同，则继续下一次循环。

![img](https://img2018.cnblogs.com/blog/1513801/201812/1513801-20181202201917077-1717388938.png)

> 说明 ：在循环的环里面，跑的快的指针一定会反复遇到跑的慢的指针 ，比如：在一个环形跑道上，两个运动员在同一地点起跑，一个运动员速度快，一个运动员速度慢。当两人跑了一段时间，速度快的运动员必然会从速度慢的运动员身后再次追上并超过，原因很简单，因为跑道是环形的。

#### 代码

```Python
class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        if head == None:
            return False
        # 快慢指针同时初始化为指向 head
        slow = fast = head
        # 快指针先走到底则结束循环（说明无环，有环永远走不到最后）
        while fast and fast.next:
            # 慢指针每次移动一格，快指针每次移动两格
            slow = slow.next
            fast = fast.next.next
            if slow is fast:
                return True
        return False
```

#### 复杂度分析

因遍历一次并记录，所以时间复杂度 $O(N)$，空间复杂度 $O(N)$。

### 2. 合并两个有序链表

#### 题目

[LeetCode 21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

#### 思路

**递归**，根据以上规律考虑本题目：

- 终止条件：当两个链表都为空时，表示我们对链表已合并完成。
- 如何递归：我们判断 l1 和 l2 头结点哪个更小，然后较小结点的 next 指针指向其余结点的合并结果。（调用递归）

#### 代码

```Python
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        if not l1: 
            return l2  # 终止条件，直到两个链表都空
        if not l2: 
            return l1
        if l1.val <= l2.val:  # 递归调用
            l1.next = self.mergeTwoLists(l1.next, l2)
            return l1
        else:
            l2.next = self.mergeTwoLists(l1, l2.next)
            return l2
```

#### 复杂度分析

**时间复杂度**：${\mathcal{O}}(m + n)$

$m，n$ 为 $l_{1}$ 和 $l_{2}$ 的元素个数。递归函数每次去掉一个元素，直到两个链表都为空，因此需要调用 $R=O(m + n)$ 次。而在递归函数中我们只进行了 next 指针的赋值操作，复杂度为 $\mathcal{O}(1)$，故递归的总时间复杂度为 ${\mathcal{O}(T) = R * \mathcal{O}(1)}={\mathcal{O}}(m + n)$。

**空间复杂度**：${\mathcal{O}}(m + n)$

对于递归调用 `self.mergeTwoLists()`，当它遇到终止条件准备回溯时，已经递归调用了 m+n 次，使用了 m+n 个栈帧，故最后的空间复杂度为 ${\mathcal{O}}(m + n)$。

### 3. 两个链表的第一个公共节点

#### 题目

[LeetCode 剑指 Offer 52. 两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)

#### 思路

我们可以使用两个指针，最开始的时候一个指向链表A，一个指向链表B，然后他们每次都要往后移动一位，顺便查看节点是否相等。如果链表A和链表B不相交，基本上没啥可说的，我们这里假设链表A和链表B相交。那么就会有两种情况，

一种是链表A的长度和链表B的长度相等，他们每次都走一步，最终在相交点肯定会相遇。

一种是链表A的长度和链表B的长度不相等，如下图所示

![image.png](https://pic.leetcode-cn.com/1602776172-sopScf-image.png)

虽然他们有交点，但他们的长度不一样，**所以他们完美的错开了，即使把链表都走完了也找不到相交点。**

我们仔细看下上面的图，**如果A指针把链表A走完了，然后再从链表B开始走（换起点）到相遇点就相当于把这两个链表的所有节点都走了一遍，同理如果B指针把链表B走完了，然后再从链表A开始（换起点）一直走到相遇点也相当于把这两个链表的所有节点都走完了。**

**所以如果A指针走到链表末尾，下一步就让他从链表B开始。同理如果B指针走到链表末尾，下一步就让他从链表A开始**。只要这两个链表相交最终肯定会在相交点相遇，如果不相交，最终他们都会同时走到两个链表的末尾（总路程相同！），我们来画个图看一下

![image.png](https://pic.leetcode-cn.com/1602776200-FJFAes-image.png)

如上图所示，A指针和B指针如果一直走下去，那么他们最终会在相交点相遇

#### 代码

```Python

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        # 设置初始起点
        node1, node2 = headA, headB
        # 若两指针指向同一节点，则退出循环
        while node1 != node2:
            node1 = node1.next if node1 else headB # 如果原先指向 A 链表的 node1 走到了头，那么换起点至 B 链表
            node2 = node2.next if node2 else headA # 如果原先指向 B 链表的 node2 走到了头，那么换起点至 A 链表

        return node1
```

#### 复杂度分析

**时间复杂度**：因为总路程为 $M+N$，所以复杂度为 $O(M+N)$。
**空间复杂度**：$O(1)$

### 4. Deduplication on a Linked List

#### 题目

[PAT 甲级 1097 Deduplication on a Linked List (25分)](https://pintia.cn/problem-sets/994805342720868352/problems/994805369774129152)

#### 思路

使用**字典**将地址映射到节点，每一个节点包含数字和下一个节点的地址，开一个**集合**，存放已经有的数字。开一个record**列表**，存放那些重复的节点的地址。

按照节点的地址来遍历字典，重复的添加到哈希，并将节点添加到record里。

难点在于不管是原字典还是record里节点的“下一项的地址”的处理。

除了集合外，不需要额外保存节点的空间，思路是改变原列表的每一项的指向。

##### 变量定义

- L 完整链表，用字典表示。
  - 键是字符串也就是address
  - 值是一个列表，包含数值和下一项的地址
- remove是存放那些重复的节点的地址
- record是一个集合，记录那些已经出现过的数字的绝对值
- temp_addr就是为了按地址遍历而设置的变量
- first_addr 是链表的第一个地址，first_du_addr 是第一个出现重复的节点的地址，默认为-1
- prev_addr是遍历过程中，记录上一个节点的地址，以便修改上一个节点的下一个节点的指向。

##### 步骤

- 按照地址来遍历链表
- 当temp_addr找到了一个数值
  - 不在record中
    - 将数值添加到record中，同时更新prev_addr = temp_addr
  - 在 record 中
    - 如果是第一个重复的数字
      - 记录first_du_addr = temp_addr
    - 如果不是第一个
      - 将record里记录的上一个地址，使它的下一个等于现在的temp_addr
    - record 添加 temp_addr
    - prev_addr表示的节点的下一项要指向temp_addr的下一项。（即原链表跳过了temp_addr这个节点，因为它是重复的）
- 记得输出record的时候，要把record最后一位的下一个设置为‘-1’

注：Python 最后两个测试点会**超时**

#### 代码

```Python
# 数据读入
L, remove, record = dict(), list(), set()
first_addr, nodes_num = input().split()
for _ in range(int(nodes_num)):
    begin, num, next_addr = input().split()
    L[begin] = [int(num), next_addr]
    
# 遍历并更新链表
temp_addr = first_addr
first_du_addr = '-1'
while temp_addr != '-1':
    num = L[temp_addr][0]
    if abs(num) not in record:
        record.add(abs(num))
        prev_addr = temp_addr
    else:
        if remove:
            L[remove[-1]][1] = temp_addr
        else:
            first_du_addr = temp_addr
        remove.append(temp_addr)
        L[prev_addr][1] = L[temp_addr][1]
    temp_addr = L[temp_addr][1]

# 输出不重复链表
temp_addr = first_addr
while temp_addr != '-1':
    print(temp_addr, L[temp_addr][0], L[temp_addr][1])
    temp_addr = L[temp_addr][1]

# 输出重复链表
if first_du_addr != '-1':
    L[remove[-1]][1] = '-1'
    print(first_du_addr, L[remove[0]][0], L[remove[0]][1])
    for i in range(1, len(remove)):
        print(L[remove[i - 1]][1], L[remove[i]][0], L[remove[i]][1])
```

### 5. Splitting A Linked List

#### 题目

[PAT 甲级 1133 Splitting A Linked List (25分)](https://pintia.cn/problem-sets/994805342720868352/problems/994805346776760320)

#### 思路

题目的意思是，给了你一串链表，然后让你把链表划分为三部分

- 小于0的
- 0到K之间的
- 大于K的

依次连接起来，其中每一部分保持原来的顺序不变。我们设三个列表分表保存这三部分，输出的时候合并在一块，即可。

##### 变量定义

- K 即题目里的K
- 三个部分的列表依次命名为
  - negative
  - zero_to_K
  - more_than_K
- _next 数组存放所有地址的下一个地址（原链表中的）
  - 下标是原地址
  - 值是它的下一个地址
- val 数组存放所有地址的值
  - 下标是地址
  - 值是值
- node 是遍历用节点
- ans 将前面三个部分连接起来

##### 步骤

- 首先读入数据，添加到_next和val数组当中。
- 从起始节点开始遍历，并按情况添加到三个部分的列表。这样可以保证三个部分的正好也是按原来的顺序的。
- 将三个部分拼接在一起。
- 输出即可。

注：Python 最后一个点会**超时**

#### 代码

```Python
addr_first, num, K = list(map(int, input().split()))
negative = []
zero_to_K = []
more_than_K = []
_next = [-1 for i in range(100001)]
val = [None for i in range(100001)]
# 读入数据
for _ in range(num):
    addr, value, next_addr = list(map(int, input().split()))
    val[addr] = value
    _next[addr] = next_addr
# 划分节点
node = addr_first
while node != -1:
    if val[node] < 0:
        negative.append(node)
    elif val[node] > K:
        more_than_K.append(node)
    else:
        zero_to_K.append(node)
    node = _next[node]
# 输出
ans = negative + zero_to_K + more_than_K
for i, j in enumerate(ans):
    if i != len(ans) - 1:
        print("%05d %d %05d" % (j, val[j], ans[i + 1]))
    else:
        print("%05d %d -1" % (j, val[j]))
```

## 字符串

### 1. 回文数

#### 题目

#### [LeetCode 9. 回文数](https://leetcode-cn.com/problems/palindrome-number/)

#### 思路 1

直接转换成字符串，并判断其与其颠倒后的对象是否相同。

#### 代码

```Python
class Solution:
    def isPalindrome(self, x: int) -> bool:
        s = str(x)
        return s == s[::-1]
```

#### 思路 2

利用数学思想：

1. 首先判断特殊情况：小于 0 的数，和，能被 10 整除且不为 0 的数，一定不是回文数
2. 新建变量 rem，用于保存由 x 计算的倒序数
3. 循环，当 `x > rem` 时，取下 x 的最后一位，并添加到 rem 上。此过程是利用数学公式，整除和求余。
4. 循环结束后的判断条件：当 `x == rem` 或 `x == rem // 10`，则是回文数；否则不是回文数。

#### 代码

```Python
class Solution:
    def isPalindrome(self, x: int) -> bool:
        # 不用字符串，则用数学思想解
        if x < 0 or (x % 10 == 0 and x !=0 ):
            return False
        rem = 0
        while x > rem:
            rem = rem * 10 + x % 10
            x = x // 10
        return x == rem or x == rem // 10 
```

### 2. 实现 strStr()

#### 题目

[LeetCode 28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)

#### 思路 1：朴素匹配法

首先，只有子串的第一个字符跟 needle 字符串第一个字符相同的时候才需要比较。

![fig](https://pic.leetcode-cn.com/Figures/28/two_pointers_start2.png)

其次，可以一个字符一个字符比较，一旦不匹配了就立刻终止。

![fig](https://pic.leetcode-cn.com/Figures/28/mismatch2.png)

如下图所示，比较到最后一位时发现不匹配，这时候开始回溯。需要注意的是，pn 指针是移动到 pn = pn - curr_len + 1 的位置，而**不是** pn = pn - curr_len 的位置。

![fig](https://pic.leetcode-cn.com/Figures/28/backtrack2.png)

这时候再比较一次，就找到了完整匹配的子串，直接返回子串的开始位置 pn - L。

![fig](https://pic.leetcode-cn.com/Figures/28/match.png)

总结：

- 移动 pn 指针，直到 pn 所指向位置的字符与 needle 字符串第一个字符相等
- 通过 pn，pL，curr_len 计算匹配长度
- 如果完全匹配（即 curr_len == L），返回匹配子串的起始坐标（即 pn - L）
- 如果不完全匹配，回溯。使 pn = pn - curr_len + 1， pL = 0， curr_len = 0

#### 代码

```Python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        L, n = len(needle), len(haystack)
        if L == 0:
            return 0

        pn = 0
        # 母串走到 n - L + 1 还未匹配，则已经失败（剩余长度不够）
        while pn < n - L + 1:
            # 找到母串与字串第一个字符相同的位置
            while pn < n - L + 1 and haystack[pn] != needle[0]:
                pn += 1
            
            # 计算最长的匹配长度
            curr_len = pL = 0
            while pL < L and pn < n and haystack[pn] == needle[pL]:
                pn += 1
                pL += 1
                curr_len += 1
            
            # 匹配成功
            if curr_len == L:
                return pn - L
            
            # 母串回溯至上一次匹配位置的下一位
            pn = pn - curr_len + 1
            
        return -1
```

#### 复杂度分析

- 时间复杂度：最坏时间复杂度为 $O((N - L)L)$，最优时间复杂度为 $O(N)$。
- 空间复杂度：$O(1)$。

#### 思路 2：*KMP 算法

kmp算法用于字符串的模式匹配，也就是找到模式字符串在目标字符串的第一次出现的位置
比如
abababc
那么bab在其位置1处，bc在其位置5处
kmp算法保证了时间复杂度为 $O(m+n)$

**基本原理**

举个例子：
![img](https://img2018.cnblogs.com/blog/1469015/201904/1469015-20190403001601218-878619954.png)
发现x与c不同后，进行移动
![img](https://img2018.cnblogs.com/blog/1469015/201904/1469015-20190403001833203-1937301435.png)
a与x不同，再次移动
![img](https://img2018.cnblogs.com/blog/1469015/201904/1469015-20190403001917622-368802532.png)
此时比较到了c与y，
于是下一步移动成了下面这样
![img](https://img2018.cnblogs.com/blog/1469015/201904/1469015-20190403002045019-2048802513.png)
这一次的移动与前两次的移动不同，之前每次比较到上面长字符串的字符位置后，直接把模式字符串的首字符与它对齐，这次并没有，原因是这次移动之前，y与c对齐，但是y前边的ab是与自己的前缀ab一样，于是ab并不用再比较，直接从第三个位置开始比较，如图：
![img](https://img2018.cnblogs.com/blog/1469015/201904/1469015-20190403002851736-1147871194.png)
所以说kmp算法对于这种情况就直接使用当前比较字符之前的最长相同的前后缀，然后将前缀与上面的长字符串对齐，继续比较后面的字符串。
这里kmp算法中的一个重要点就来了，如何找到模式字符串中每位字符之前的最长相同前后缀呢
这里继续用一个例子举例：
![img](https://img2018.cnblogs.com/blog/1469015/201904/1469015-20190403153512876-1429279941.png)

下面的数字记录以该字符为结尾的最长前后缀相同子串的长度，先初始化为0,并且第一个字符下的数字确认为0
然后开始比较：
![img](https://img2018.cnblogs.com/blog/1469015/201904/1469015-20190403153553577-1463129477.png)

a与b不同，那么b下的数字也为0同理a与c不同，c下的数字也为0，接下来a与a对齐，如下
![img](https://img2018.cnblogs.com/blog/1469015/201904/1469015-20190403153645998-893756258.png)

此时a与a相同，那么a下面的数字为1，也就是第二排字符串中当前比对的字符索引+1
接下来b与b相同，c与a不相同，那么此时上面的字符串不动，下面的字符串移动到当前比对位置即c的前一位的下方的数字的位置，如图：
移动前
![img](https://img2018.cnblogs.com/blog/1469015/201904/1469015-20190403154112174-1541623486.png)
c的前一位是b，b下方的数字是0，所以将下面字符串的第0位与之前的比对位置对其，即：
![img](https://img2018.cnblogs.com/blog/1469015/201904/1469015-20190403154314286-1614292137.png)
当前比对位置如箭头所示，然后继续向后比较，一直比到c与a：
![img](https://img2018.cnblogs.com/blog/1469015/201904/1469015-20190403154445762-132548019.png)
此时c与a不相同，那么比较下面字符的前一个字符的下方数字的位置，如图
![img](https://img2018.cnblogs.com/blog/1469015/201904/1469015-20190403154728851-1289481369.png)
也就是位置为2的地方与上面比对位置对齐：
![img](https://img2018.cnblogs.com/blog/1469015/201904/1469015-20190403154827046-273958539.png)
此时c与c相同，整个字符串自比对完成：
![img](https://img2018.cnblogs.com/blog/1469015/201904/1469015-20190403154929519-1262309740.png)
此时可能会没有理解为什么匹配不成功的时候要再比对其前一位字符下的数字的位置，那是因为这是要找到前一个字符位置下的最长相同前缀中的最长相同前缀，就举刚才的例子：
![img](https://img2018.cnblogs.com/blog/1469015/201904/1469015-20190403154445762-132548019.png)
此时a前边是abcab，所以要找到abcab的最长相同前缀，就是ab，这时
![img](https://img2018.cnblogs.com/blog/1469015/201904/1469015-20190403155623200-1255442865.png)
然后再移动到ab与ab对其的位置继续比较即可

#### 代码

```Python
class Solution:
    def strStr(self, haystack, needle):
        if len(needle) == 0: 
            return 0
 
        n, m = len(haystack), len(needle)
        next = [0] * m
        self.GetNext(needle, next)  # 初始化next数组
 
        i, j = 0, 0
        while i < n and j < m:
            if j == -1 or haystack[i] == needle[j]: # 继续向前
                i, j = i + 1, j + 1
            else: # 回溯
                j = next[j]
        # 匹配成功返回 i - m，失败返回 -1
        return i - m if j >= m else -1
 
    def GetNext(self, t, next):  # 计算next数组
        j, k, next[0], n = 0, -1, -1, len(next)
        while j < n - 1:
            if k == -1 or t[j] == t[k]:
                j, k = j + 1, k + 1
                next[j] = k
            else: # 回溯
                k = next[k]
```

#### 复杂度分析

时间复杂度：$O(M+N)$

空间复杂度：$O(M)$

### 3. A Delayed Palindrome

#### 题目

[PAT 甲级 1136 A Delayed Palindrome (20分)](https://pintia.cn/problem-sets/994805342720868352/problems/994805345732378624)

#### 思路

- 开始十次遍历
  - 每次遍历前把字符串反转一下
  - 如果反转后和原字符串是相等的
    - 输出相等的那段文字并break
  - 否则，求它们俩的和
  - 输出
  - 使原数等于刚刚的和的字符串的表示
- 十次都没有则输出没找到。

注意输出要以字符串的形式，不然前面的0会被忽略掉

#### 代码

```Python
a = input()
for i in range(10):
    b = a[::-1] # 反转字符串
    if b == a:
        print(a, "is a palindromic number.")
        break
    sums = int(a) + int(b)
    print(a, "+", b, "=", sums)
    a = str(sums)
else:
    print("Not found in 10 iterations.")
```

### 4. Google Recruitment

#### 题目

[PAT 甲级 1152 Google Recruitment (20分)](https://pintia.cn/problem-sets/994805342720868352/problems/1071785055080476672)

#### 思路

给定一长串数和一个长度，让你在这串数中找到一个字符串，组成的数字是素数，字符串的长度刚好等于给定的。有多个就输出排在第一个的。

那么就以这个长度为窗口，不断滑动，即可。

注意输出的时候要输出切分的字符串，不能输出整数，不然前面的0会被吃掉。

#### 代码

```Python
def isPrime(a):
    if a == 1:
        return False
    if a == 2 or a == 3:
        return True
    if a % 2 == 0:
        return False
    for i in range(3, int(a ** 0.5) + 1, 2):
        if a % i == 0:
            return False
    return True


length, digit = list(map(int, input().split()))
num = input() # 原串
for i in range(len(num) - digit + 1): # 窗口不断向右滑动
    test = num[i: i + digit] # 切分后的字符串
    if isPrime(int(test)):
        print(test)
        break
else:
    print("404")
```

## 栈和队列

### 1. 用两个栈实现队列

#### 题目

[LeetCode 剑指 Offer 09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

#### 思路

维护两个栈，第一个栈支持插入操作，第二个栈支持删除操作。

根据栈**先进后出**的特性，我们每次往第一个栈里插入元素后，第一个栈的底部元素是最后插入的元素，第一个栈的顶部元素是下一个待删除的元素。为了维护队列先进先出的特性，我们引入第二个栈，用第二个栈维护待删除的元素，在执行删除操作的时候我们首先看下第二个栈是否为空。如果为空，我们将第一个栈里的元素一个个弹出插入到第二个栈里，这样第二个栈里元素的顺序就是待删除的元素的顺序，要执行删除操作的时候我们直接弹出第二个栈的元素返回即可。

**函数设计**：
题目只要求实现 加入队尾 appendTail() 和 删除队首 deleteHead() 两个函数的正常工作，因此我们可以设计栈 A 用于加入队尾操作，栈 B 用于将元素倒序，从而实现删除队首元素。

加入队尾 appendTail() 函数： 将数字 val 加入栈 A 即可。
删除队首 deleteHead() 函数： 有以下三种情况。

- 当栈 B 不为空： B 中仍有已完成倒序的元素，因此直接返回 B 的栈顶元素。
- 否则，当 A 为空： 即两个栈都为空，无元素，因此返回 -1 
- 否则：将栈 A 元素全部转移至栈 B 中，实现元素倒序，并返回栈 B 的栈顶元素。

#### 代码

```Python
class CQueue:
    def __init__(self):
        self.A, self.B = [], []

    def appendTail(self, value: int) -> None:
        self.A.append(value)

    def deleteHead(self) -> int:
        if self.B: 
            return self.B.pop()
        if not self.A: 
            return -1
        while self.A:
            self.B.append(self.A.pop())
        return self.B.pop()
```

### 2. Pop Sequence

#### 题目

[PAT 甲级 1051 Pop Sequence (25分)](https://pintia.cn/problem-sets/994805342720868352/problems/994805427332562944)

#### 思路

设置一个 stack 数组，用来存储未弹出的元素。start 变量从 1 开始递增到 N。

- 如果 stack 中没有元素，则存入 stack 数组。
- 如果 start 等于 pop 数组首元素，则递增 start，且弹出 pop 数组中的首个元素。
- 如果 stack 数组中有元素，且不多于 M-1 个，且不等于 pop 数组首元素，则加入 stack 数组。
- 如果 stack 中有了 M-1 个元素，且第 M 个元素不等于 pop 元素的首元素，则将 flag 变量设为 False，不可能有这个弹出顺序。

最后将 pop 数组剩余和 stack 数组的倒置顺序比较，如果相等，可以说明可以按照这个顺序将 stack 中剩余元素弹出，该顺序存在。

#### 代码

```Python
def main():
    line1 = input().split(" ")
    m, n, k = int(line1[0]), int(line1[1]), int(line1[2])
    for x in range(k):
        line = input().split(" ")
        pop = [int(x) for x in line]
        stack = []
        start = 1
        flag = True
        while(start <= n):
            if(start == pop[0]):
                start += 1
                pop.pop(0)
            elif(len(stack) == 0):
                stack.append(start)
                start += 1
            elif(stack[-1] == pop[0]):
                stack.pop(-1)
                pop.pop(0)
            elif(len(stack) < m-1):
                stack.append(start)
                start += 1
            else:
                flag = False
                break
        stack = stack[::-1]
        if stack != pop:
            flag = False
        if(flag):
            print("YES")
        else:
            print("NO")
if __name__ == "__main__":
    main()
```

### 3. 验证栈序列

#### 题目

[LeetCode 946. 验证栈序列](https://leetcode-cn.com/problems/validate-stack-sequences/)

#### 思路

用一个队列来存储pop数组，遍历push数组，将每个元素push到栈中，通过对比栈的最后一个元素是否等于队列的第一个元素，不相等的话继续push入栈中对比，当有相同时出栈和出队列，如果栈为空，说明符合顺序规定

#### 代码

```Python
class Solution:
    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:
        queue_order = popped
        stack = []
        for i in range(len(pushed)):  # 遍历push的元素
            stack.append(pushed[i])  # 将每个元素放入栈中
            while len(stack) > 0 and stack[-1] == queue_order[0]:  # 栈的长度>0 and 栈的最后一个元素等于队列的第一个元素
                stack.pop()  # 栈删除最后一个元素
                queue_order.pop(0) # 队列删除第一个元素
        if len(stack) > 0:
            return False

        return True
```

## 二叉树和树

### 1. Infix Expression

#### 题目

[PAT 甲级 1130 Infix Expression (25分)](https://pintia.cn/problem-sets/994805342720868352/problems/994805347921805312)

#### 思路

首先是建立二叉树，然后就是中序遍历。比较特殊的情况在于**括号的处理**

- 如果这个点是叶子节点或者最外层节点，那么不用加括号
- 否则，左右都要加括号。

我们可以把答案先存储起来，然后移除最外层的括号。**要注意如果只有一个节点的特殊情况。**

##### 变量定义

- Node 是一个节点，一个class，包含
  - val 值，也就是节点的内容，字符串
  - 左孩子
  - 右孩子
  - 父亲（为了便于找根）输出
- nodes 存放所有的Node，可以方便用下标来索引
- root 是这个树的树根
- ans 存放答案

##### 步骤

- 建立树
- 找到树根
- 中序遍历
  - 对非叶子节点的
    - 先放左括号
    - 递归左子树
    - 放自己
    - 递归右子树
    - 放右括号
  - 对叶子节点
    - 只放自己
- 删掉左右括号输出

#### 代码

```Python
class Node:
    def __init__(self):
        self.val = None
        self.left = None
        self.right = None
        self.father = None


n = int(input())
nodes = [Node() for _ in range(n)]
for i in range(n):
    val, left, right = input().split()
    nodes[i].val = val
    if left != "-1":
        nodes[i].left = nodes[int(left) - 1]
        nodes[i].left.father = nodes[i]
    if right != "-1":
        nodes[i].right = nodes[int(right) - 1]
        nodes[i].right.father = nodes[i]

root = nodes[0]
while root.father:
    root = root.father

ans = []
# 中序遍历
def inorder(i: Node):
    if i.left or i.right:
        ans.append("(")
        if i.left:
            inorder(i.left)
        ans.append(i.val)
        if i.right:
            inorder(i.right)
        ans.append(")")
    else:
        ans.append(i.val)

inorder(root)
ans = ans[1: -1] if len(ans) > 1 else ans # 移除最外层括号，要注意只有一个节点的特殊情况。
print("".join(ans))
```

### 2. 二叉树中的最大路径和

#### 题目

[LeetCode 124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

#### 思路

**递归**
首先，考虑实现一个简化的函数 maxGain(node)，该函数计算二叉树中的一个节点的最大贡献值，具体而言，**就是在以该节点为根节点的子树中寻找以该节点为起点的一条路径，使得该路径上的节点值之和最大**。

具体而言，该函数的计算如下

- 空节点的最大贡献值等于 0
- 非空节点的最大贡献值等于节点值与其子节点中的最大贡献值之和（对于叶节点而言，最大贡献值等于节点值）

例如，考虑如下二叉树。

```
   -10
   / \
  9  20
    /  \
   15   7
```

叶节点 9、15、7 的最大贡献值分别为 9、15、7。

得到叶节点的最大贡献值之后，再计算非叶节点的最大贡献值。节点 20 的最大贡献值等于 $20+\max(15,7)=35$，节点 −10 的最大贡献值等于 $-10+\max(9,35)=25$。

上述计算过程是递归的过程，因此，对根节点调用函数 maxGain，即可得到每个节点的最大贡献值。

根据函数 maxGain 得到每个节点的最大贡献值之后，如何得到二叉树的最大路径和？

对于二叉树中的一个节点，**该节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值**，**如果子节点的最大贡献值为正，则计入该节点的最大路径和，否则不计入该节点的最大路径和**。维护一个全局变量 maxSum 存储最大路径和，在递归过程中更新 maxSum 的值，最后得到的 maxSum 的值即为二叉树中的最大路径和。

#### 代码

```Python
class Solution:
    def __init__(self):
        self.maxSum = float("-inf") # 初始化最大值为 -inf

    def maxPathSum(self, root: TreeNode) -> int:
        def maxGain(node):
            if not node:
                return 0

            # 递归计算左右子节点的最大贡献值
            # 只有在最大贡献值大于 0 时，才会选取对应子节点
            leftGain = max(maxGain(node.left), 0)
            rightGain = max(maxGain(node.right), 0)
            
            # 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值
            priceNewpath = node.val + leftGain + rightGain
            
            # 更新答案
            self.maxSum = max(self.maxSum, priceNewpath)
        
            # 返回节点的最大贡献值
            return node.val + max(leftGain, rightGain)
   
        maxGain(root)
        return self.maxSum
```

### 3. Total Sales of Supply Chain

#### 题目

[PAT 甲级 1079 Total Sales of Supply Chain (25分)](https://pintia.cn/problem-sets/994805342720868352/problems/994805388447170560)

#### 思路

这道题算比较简单，就是计算传销的最下级的销售额。简单的说，对图的一个遍历，更新每个节点的数据（传销层次）。然后算出最终结果。使用`Python3`的话会有三个点超时过不了，使用 `C++` 就OK了。使用`BFS`和`DFS`均可，注意层级的更新顺序就行了。

##### 变量定义

- companies是一个列表，包含所有公司，下标即公司id
- 一个公司以一个字典的形式表示，包含层数
- 对retailer，会添加nums键，代表卖了多少份
- 对非retailer，会添加sons键，值是一个列表，代表子公司数量

#### 代码

```Python
# 第一行元数据的输入
a = input().split()
companies_num = int(a[0])
init_price = float(a[1])
rate = 1 + float(a[2]) / 100

companies = [{'level': 0} for i in range(companies_num)]

# 更新每个公司的sons键或nums键
for father in range(companies_num):
    info = input().split()
    if info[0] != '0':
        companies[father]['sons'] = []
        for son in info[1:]:
            companies[father]['sons'].append(int(son))
    else:
        companies[father]['nums'] = int(info[1])

# 更新每个公司的层级，可以使用BFS或DFS，这里使用了DFS。BFS需要把队列改为栈
# 遇到了retailer就直接计算总和了
sums = 0
queue = [0]
while queue:
    father = queue.pop()
    if 'sons' in companies[father].keys():
        for son in companies[father]['sons']:
            companies[son]['level'] = companies[father]['level'] + 1
            queue.insert(0, son)
    else:
        sums += companies[father]['nums'] * init_price * rate ** companies[father]['level']

print(round(sums, 1))
```

### 4. 对称二叉树

#### 题目

[LeetCode 101.对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

#### 思路

乍一看无从下手，但用递归其实很好解决。
根据题目的描述，镜像对称，就是左右两边相等，也就是左子树和右子树是相当的。
注意这句话，左子树和右子相等，也就是说**要递归的比较左子树和右子树**。
我们将根节点的左子树记做 left，右子树记做 right。**比较 left 是否等于 right，不等的话直接返回就可以了**。
如果相当，比较 left 的左节点和 right 的右节点，再比较 left 的右节点和 right 的左节点
比如看下面这两个子树(他们分别是根节点的左子树和右子树)，能观察到这么一个规律：

- 左子树 2 的左孩子 == 右子树 2 的右孩子
- 左子树 2 的右孩子 == 右子树 2 的左孩子

```
    2         2
   / \       / \
  3   4     4   3
 / \ / \   / \ / \
8  7 6  5 5  6 7  8
```

根据上面信息可以总结出递归函数的两个条件：
终止条件：

- **left 和 right 不等**
- **或者 left 和 right 都为空**

**递归地比较 left，left 和 right.right，递归比较 left，right 和 right.left**
动态图如下：

![img](https://pic.leetcode-cn.com/2449af8862537df2cbbc45a07764415c1a10769677c822fa271ea7447c8fa128-2.gif)

算法的时间复杂度是 $O(n)$，因为要遍历 n 个节点
空间复杂度是 $O(n)$，空间复杂度是递归的深度，也就是跟树高度有关，最坏情况下树变成一个**链表**结构，高度是 n。

#### 代码

```Python
class Solution(object):
	def isSymmetric(self, root):
		"""
		:type root: TreeNode
		:rtype: bool
		"""
		if not root:
			return True
		def dfs(left, right):
			# 递归的终止条件是两个节点都为空
			# 或者两个节点中有一个为空
			# 或者两个节点的值不相等
			if not (left or right):
				return True
			if not (left and right):
				return False
			if left.val != right.val:
				return False
			return dfs(left.left, right.right) and dfs(left.right, right.left)
		# 用递归函数，比较左节点，右节点
		return dfs(root.left, root.right)
```

> 想想这题不用递归怎么做？

### 5. Counting Leaves

#### 题目

[PAT 甲级 1004 Counting Leaves (30分)](https://pintia.cn/problem-sets/994805342720868352/problems/994805521431773184)

#### 思路

题目的意思是给你一棵树，让你输出每层的叶子节点个数，那很明显就是广度优先遍历了。

##### 变量定义

- members 列表记录所有成员
  - 下标是成员id
  - 值是一个列表，包含这个成员的所有孩子的id
- level 列表记录每层的叶子节点个数
  - 下标是层数
  - 值是叶子节点个数
- temp_num是计算这层的叶子结点的中间变量

##### 步骤

- 广度优先遍历要配合先入先出的**队列**，队列初始化为拥有一个根节点。**队列存放的所有节点都拥有相同的层数。**
- 当队列不为空的时候
  - 记录现在队列的长度
  - temp_num 清零
  - 遍历现在这个队列
    - 遍历队列里每一项的所有孩子
      - 如果孩子是没有孩子的，temp_num + 1
      - 否则，添加到队列中
  - level添加temp_num项
- 最后输出level即可
- 注意只有一个节点的特殊情况！

#### 代码

```Python
# 读入第一行信息
num_nodes, num_non_leaf = list(map(int, input().split()))
# 先把只有一个根节点的特殊情况给处理咯
if num_nodes == 1:
    print(1)
else:
    # 初始化数据结构
    members = [[] for _ in range(num_nodes + 1)]
    for _ in range(num_non_leaf):
        a = list(map(int, input().split()))
        members[a[0]] = a[2:]
    # 广度优先遍历
    level, que = [0], [1]
    while que:
        length, temp_num = len(que), 0
        for _ in range(length):
            father = que.pop()
            for son in members[father]:
                if not members[son]:
                    temp_num += 1
                else:
                    que.insert(0, son)
        level.append(temp_num)
    # 输出结果
    print(" ".join(list(map(str, level))))
```

### 6. Invert a Binary Tree

#### 题目

[PAT 甲级 1102 Invert a Binary Tree (25分)](https://pintia.cn/problem-sets/994805342720868352/problems/994805365537882112)

#### 思路

题目里让我们建立一个左右相反的二叉树，在输入的时候左右反一反就行了。建立好树然后递归遍历。层次遍历要在递归中记录层数，按照“根左右”的顺序，其中左右按同一层算，最后按层数排序并输出。中序遍历即“左根右”递归，并输出即可。

##### 变量定义

- Node是一个class，是一个节点，成员有
  - val 值
  - left 左孩子
  - right 右孩子
  - father 父节点
- root 根节点
- ans 存放答案

步骤

- 首先建立一个列表，存放所有的节点（值就是下标）
- 读入左右孩子的分布，这里反转一下左右
- 利用father找到根部
- 层次遍历并输出
- 中序遍历并输出

#### 代码

```Python
class Node:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
        self.father = None

# 数据结构初始化
n = int(input())
tree = [Node(i) for i in range(n)]
for i in range(n):
    right, left = input().split()
    if left != "-":
        tree[i].left = tree[int(left)]
        tree[i].left.father = tree[i]
    if right != "-":
        tree[i].right = tree[int(right)]
        tree[i].right.father = tree[i]
# 找到根部
root = tree[0]
while root.father is not None:
    root = root.father
# 存放答案
ans = []

# 层次遍历
def levelorder(node, level):
    ans.append([node.val, level])
    if node.left:
        levelorder(node.left, level + 1)
    if node.right:
        levelorder(node.right, level + 1)

levelorder(root, 0)
ans.sort(key=lambda x: x[1])
print(" ".join(list(map(str, [i[0] for i in ans]))))

# 中序遍历
def inorder(node):
    if node.left:
        inorder(node.left)
    ans.append(node.val)
    if node.right:
        inorder(node.right)

ans.clear()   
inorder(root)
print(" ".join(list(map(str, ans))))
```

### 7. Postorder Traversal

#### 题目

[PAT 甲级 1138 Postorder Traversal (25分)](https://pintia.cn/problem-sets/994805342720868352/problems/994805345078067200)

#### 思路

题目给出了前序遍历和中序遍历，求后序遍历的第一个数。

- 前序遍历是**根左右**
- 中序遍历是**左根右**
- 后序遍历是**左右根**

我们可以这样画图来辅助理解，对于一棵树或子树，都符合下面的规律

```
前序：  根[    左    ][    右    ]
中序：  [    左    ]根[    右    ]
```

而我们想要的是后序遍历的第一项，从逻辑上来说

- 就是一个节点如果有左子树的，就深入左子树，不管右子树。
- 如果有右子树的，就深入右子树。
- 都没有的，输出它。

这样子剪枝，就可以大大减少复杂度，将递归优化成**尾递归**

> 左右边界下标的计算，建议在草稿纸上先演算一边
>
> **由于这道题测试数据格式有误，Python有一个点会非零返回。**

#### 代码

```Python
def judge(pre_left, in_left, in_right):
    in_root = _in.index(pre[pre_left])
    if in_left <= in_root - 1:
        judge(pre_left + 1, in_left, in_root - 1) # 1.
    elif in_root + 1 <= in_right:
        judge(pre_left + (in_root - in_left) + 1, in_root + 1, in_right) # 2.
    else:
        print(_in[in_root])
    # 1. 和 2. 中的边界下标建议在草稿纸上计算一下

n = int(input())
pre = list(map(int, input().split()))
_in = list(map(int, input().split()))
judge(0, 0, n - 1)
```

## 图

### 1. N 皇后

#### 题目

[LeetCode 51. N 皇后](https://leetcode-cn.com/problems/n-queens/)

#### 思路

题意很简单：将N个皇后放置在 N * N 的棋盘之中，保证每行，每列，每个对角线只出现一个皇后

- 问题1：如何进行遍历？
  由于每行只能出现一个皇后，所以这里我们可以选择按行来遍历，一行一行的进行放置，放置的时候只要保证每一列和每一条对角线上不存在皇后即可
- 问题2：如何判断对角线上是否有皇后？
  检查左斜上方和右斜上方即可（具体看代码注释）

#### 代码

```Python
class Solution:
    def solveNQueens(self, N) -> ListNode:
        # 初始化用于放Queue的棋盘，二维列表
        checkerboard = [["." for j in range(N)] for i in range(N)]
        # 存放答案的列表
        result = []
        
        # 检查第row行 第col列是否可以放Queue
        def check(row, col):
            # 遍历到当前的行
            # 只用考虑 row 及 小于 row 的情况-因为后面的棋盘都是空的
            for row_index in range(row):
                # 当遍历到当前放置的行时进行判断， 是否已经放置了Queue
                if row_index == row:
                    if "Q" in checkerboard[row_index]:
                        return False
                # 判断遍历每行时，第col列是否已经放置了Queue
                if "Q" == checkerboard[row_index][col]:
                    return False
            # 只判断斜上方有没有其他皇后
            return check_left_up(row, col) and check_right_up(row, col)
        
        # 判断当前位置 左斜上方是否存在Queue
        def check_left_up(row, col):
            while row > 0 and col > 0:
                row -= 1
                col -= 1
                if "Q" in checkerboard[row][col]:
                    return False
            return True
        
        # 判断当前位置 右斜上方是否存在Queue
        def check_right_up(row, col):
            while row > 0 and col < N - 1:
                row -= 1
                col += 1
                if "Q" in checkerboard[row][col]:
                    return False
            return True
        
        # 把符合条件的棋盘加入result
        def add_result():
            tem_list = []
            for each_row in checkerboard:
                tem = "".join(each_row)
                tem_list.append(tem)
            result.append(tem_list)

        # 主体函数
        def input(row):
            # 终止条件
            if row >= N: add_result()
            # 列的下标每次都从 0 ~ N-1 保证每种情况都试过
            for input_col in range(N):
                if check(row, input_col):
                    checkerboard[row][input_col] = "Q"
                    # 因为一行只会有一个Queue，所以该行放置了Queue后自然要从下一行开始，减少没有必要的尝试
                    input(row + 1)
                    # 进行尝试后如果不行一定要记得还原之前的操作（回溯）
                    checkerboard[row][input_col] = "."   
        # 从第0行开始
        input(0)
        return result
```

### 2. Vertex Cover

#### 题目

[PAT 甲级 1134 Vertex Cover (25分)](https://pintia.cn/problem-sets/994805342720868352/problems/994805346428633088)

#### 思路

题目意思是给你一个图，然后给你一堆节点，让你判断和这些点相邻的所有道路是不是涵盖了整张图的道路

所以我们要考虑的首要问题是**怎么表示一个道路**

- 我们可以给定一个虚拟的道路编号，从0开始，一直到给定的道路数量-1
- 这样子，我们可以在读取的时候，读到两个节点，那么这两个节点的道路数组中都添加这一条道路编号，同时道路编号+1
- 在查询的时候，我们预设每条道路都是没有访问过的。
- 然后对查询的每个节点，标记它的所有道路为访问过
- 最后遍历所有的道路有没有被访问过即可。

##### 变量定义

- roads 是道路数组，包含了所有的道路
  - 下标是节点的id
  - 值是这个节点所联通的所有道路的编号的数组
- index 是边读取边更新的道路下标
- nodes 是所有查询中读取到的节点列表
- visited 标记哪些道路是已经走过的列表
  - 下标是道路id
  - 值是True或False

#### 代码

```Python
num_vertice, num_edge = list(map(int, input().split()))
roads = [[] for _ in range(num_vertice)]
# 读入
index = 0
for _ in range(num_edge):
    a,b = list(map(int, input().split()))
    roads[a].append(index)
    roads[b].append(index)
    index += 1
# 查询
for _ in range(int(input())):
    nodes = list(map(int, input().split()[1:]))
    visited = [False for _ in range(num_edge)]
    for node in nodes:
        for road in roads[node]:
            visited[road] = True
    if all(visited):
        print("Yes")
    else:
        print("No")
```

### 3. Vertex Coloring

#### 题目

[PAT 甲级 1154 Vertex Coloring (25分)](https://pintia.cn/problem-sets/994805342720868352/problems/1071785301894295552)

#### 思路

给你一张图，给你每个点的颜色，让你判断是不是每个路径的两个端点颜色不同，并输出总共用了几种颜色。直接把路径存储起来，然后用集合判定颜色数量即可。

- 读取道路信息
- 读取颜色信息
- 遍历每条路
- 如果有一条路两个端点颜色相同，输出No，break
- 否则，输出有几种颜色。取集合取长度即可。

##### 变量定义

- roads 存放所有的路，是一个列表
  - 一条路由一个二元素列表组成，即两个端点
- color 是每个节点的颜色

#### 代码

```Python
num_vertice, num_edges = list(map(int, input().split()))
roads = [None for _ in range(num_edges)]

for i in range(num_edges):
    a, b = list(map(int, input().split()))
    roads[i] = [a, b]
    
for _ in range(int(input())):
    color = list(map(int, input().split()))
    # 检查每条路的两个端点颜色是否相同
    for road in roads:
        if color[road[0]] == color[road[1]]:
            print("No")
            break
    else:
        print("%d-coloring" % len(set(color)))
```

### 4. Battle Over Cities

#### 题目

[PAT 甲级 1013 Battle Over Cities (25分)](https://pintia.cn/problem-sets/994805342720868352/problems/994805500414115840)

#### 思路

题目是给定一个连通图，问你如果缺少了一个城市，剩下的要补几条道路才能连通。如果从道路的方向想，就会感觉很困难，无从下手，但是可以换个角度想。例如，有一块大陆，如果中间有一片陆地变成了水，剩下的就变成了几个岛屿。如果让你求岛屿数量，那么可以使用BFS，DFS和并查集。

和这题有什么关系呢？

这样想，如果国家变成了n个城邦，那么这n个不连通的城邦至少需要多少条道路才能联通？

答案是n-1，你把它们一个一个连起来排成一列就行了，这样所有的都能相通

所以题目可以转化为求**去除了这个城市以后，剩下的连通的城邦数量**

同样可以使用BFS，DFS 与 并查集

- BFS就是和队列配合一起进行广度优先遍历。一次性从一个节点出发，找到它的所有连通量。也就是从一个城扩散到整个城邦。
- DFS就是和栈配合一起进行广度优先遍历。一次性从一个节点出发，找到它的所有连通量。也就是从一个城扩散到整个城邦。也可以使用递归。

##### 变量定义

- roads 是一个列表（数组）
  - 下标是城市id
  - 值是列表(vector)，代表这个城市联通的所有城市

注：使用Python的代码最后一个点会超时

#### 代码

**BFS**：

```Python
N, M, K = list(map(int, input().split()))
roads = [[] for i in range(N)]
for _ in range(M):
    a = input().split()
    roads[int(a[0]) - 1].append(int(a[1]) - 1)
    roads[int(a[1]) - 1].append(int(a[0]) - 1)

check = list(map(int, input().split()))
for i in check:
    count = 0
    visited = [False for _ in range(N)]
    visited[i - 1] = True
    for start, _ in enumerate(roads):
        if not visited[start]:
            count += 1
            que = [start]
            while que:
                city = que.pop()
                for destination in roads[city]:
                    if not visited[destination]:
                        visited[destination] = True
                        que.insert(0, destination)
    print(count - 1)
```

**DFS + 递归：**

```Python
N, M, K = list(map(int, input().split()))
roads = [[] for i in range(N)]
for _ in range(M):
    a = input().split()
    roads[int(a[0]) - 1].append(int(a[1]) - 1)
    roads[int(a[1]) - 1].append(int(a[0]) - 1)


def dfs(city):
    visited[city] = True
    for destination in roads[city]:
        if not visited[destination]:
            dfs(destination)


check = list(map(int, input().split()))
for i in check:
    count = 0
    visited = [False for _ in range(N)]
    visited[i - 1] = True
    for start, _ in enumerate(roads):
        if not visited[start]:
            count += 1
            dfs(start)
    print(count - 1)
```

**DFS**：

```Python
N, M, K = list(map(int, input().split()))
roads = [[] for i in range(N)]
for _ in range(M):
    a = input().split()
    roads[int(a[0]) - 1].append(int(a[1]) - 1)
    roads[int(a[1]) - 1].append(int(a[0]) - 1)

check = list(map(int, input().split()))
for i in check:
    count = 0
    visited = [False for _ in range(N)]
    visited[i - 1] = True
    for start, _ in enumerate(roads):
        if not visited[start]:
            count += 1
            stk = [start]
            while stk:
                city = stk.pop()
                for destination in roads[city]:
                    if not visited[destination]:
                        visited[destination] = True
                        stk.append(destination)
    print(count - 1)
```

### 5. Acute Stroke

#### 题目

[PAT 甲级 1091 Acute Stroke (30分)](https://pintia.cn/problem-sets/994805342720868352/problems/994805375457411072)

#### 思路

题目看起来很复杂，其实可以简化一下。

- 想象在一个二维地图中
- 0表示水，1表示陆地
- 你要找到这个地图中的陆地数量

提到这个问题，一般的做法是使用`DFS`或`BFS`或`并查集`，可以参照在 LeetCode 上[岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)这道题的题解。我建议使用`DFS`或者`BFS`来做，`并查集`代码量会比较大。

这道题复杂在

- 陆地数量要大于一个阀值
- 而且图像是三维的

第一个好办，第二个的话，就是要对于邻居节点作修改。二维图对于一个节点来说，会有上下所有四个邻居，而三维图呢，是六个邻居。即，除了上下左右，还有头上和脚下。要注意这三维的顺序。

##### 变量定义

- `three_d_image` 是一个三维数组，记录一个坐标的结果是1还是0
- `visited` 是一个三维数组，记录这个坐标有没有被访问过

##### 步骤

采用 `DFS` 广度优先遍历，会有两个点超时，这道题建议使用`C++`来做。

使用 `BFS`也一样，无非是把栈换成队列，也是后两个点超时。

#### 代码

```Python
# 读入数据与数据结构定义
M, N, L, T = list(map(int, input().split()))
three_d_image = [[None for _ in range(M)] for _ in range(L)]
visited = [[[False for _ in range(N)] for _ in range(M)] for _ in range(L)]
ans = 0
for i in range(L):
    for j in range(M):
        condition = list(map(int, input().split()))
        three_d_image[i][j] = condition
# 开始 BFS
for i in range(L):
    for j in range(M):
        for k in range(N):
            # 出现了一个新块
            if three_d_image[i][j][k] == 1 and not visited[i][j][k]:
                count = 0
                stk = []
                stk.append([i, j, k])
                visited[i][j][k] = True
                while stk:
                    old = stk.pop()
                    count += 1
                    # 使用zip来遍历六个方向上的点
                    for increment in zip([1, 0, 0, -1, 0, 0], [0, 1, 0, 0, -1, 0], [0, 0, 1, 0, 0, -1]):
                        new = [x + y for x, y in zip(increment, old)]
                        # 判断这个邻居坐标在图像范围内，没有被访问过，同时状况是1
                        if 0 <= new[0] < L and 0 <= new[1] < M and 0 <= new[2] < N and three_d_image[new[0]][new[1]][
                            new[2]] == 1 and not visited[new[0]][new[1]][new[2]]:
                            visited[new[0]][new[1]][new[2]] = True
                            stk.append([new[0], new[1], new[2]])
                if count >= T:
                    ans += count
print(ans)
```

### 6. Integer Factorization

#### 题目

[PAT 甲级 1103 Integer Factorization (30分)](https://pintia.cn/problem-sets/994805342720868352/problems/994805364711604224)

#### 思路

这道题题目意思有点抽象，但是借助例子应该能看懂。

> n 就是等号左边的数，K 就是右边加的那些项的个数，P就是指数。我们最大的底数是`pow(n, 1/P)`，从1到这个数之间的所有数都是潜在的底数，且可以重复选取。一开始我想到用DFS，以数值的大小为转移。但是这样的话，每次要对所有潜在的底数DFS，复杂度过高。更好的方法是**以底数为转移，每次dfs更新底数**。

##### 变量定义

- n,k,p 对应题目里的原数，项数和指数
- ans是最佳的底数们，是一个列表
- maxFacsum 是目前最佳的底数们的底数和
- sums 是目前计算中的指数和
- facsums 是目前计算中的底数和
- now 是目前计算中的底数们

##### 步骤

- 从最大的潜在底数开始DFS
  - 更新sums和facsums和now
  - 继续DFS这个底数——因为底数可以重复选取
  - 回溯sums和facsums和now
  - DFS上一个底数
- 当DFS到sums > n 或 now里面多于k了或者index 为0 的时候
  - 及时剪枝
- 当DFS到sums = n 且 now的个数等于k的时候
  - 比较最佳解和目前解的底数和，判断是否要更新最佳解。
- 输出即可

注：这道题使用Python会有一个点**超时**

#### 代码

```Python
n, k, p = list(map(int, input().split()))
ans, maxFacSum = [], 0
sums, facSums, now = 0, 0, []


def DFS(index):
    global sums, facSums, now, ans, maxFacSum, n, k, p
    if sums > n or len(now) > k or index == 0:
        return
    if sums == n and len(now) == k and facSums > maxFacSum:
        maxFacSum = facSums
        ans = now.copy()
        return

    now.append(index)
    sums += pow(index, p)
    facSums += index
    DFS(index)
    now.pop()  				# 回溯
    sums -= pow(index, p)
    facSums -= index
    DFS(index - 1)


DFS(int(pow(n, 1 / p)))
if ans:
    ans = list(map(lambda x: str(x) + "^" + str(p), ans))
    ans = " + ".join(ans)
    print(n, "=", ans)
else:
    print("Impossible")
```

### 7. *Emergency

#### 题目 

[PAT 甲级 1003 Emergency (25分)](https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376)

#### 思路

道路的长度相当于道路的边权，救灾部队的数量相当于点的点权（权值）。使用 **dijkstra算法** 求解最短路径的同时求最大的点权。
变量定义：

- weight 数组存储从起点到索引表示点的最短路径长度
- power 数组存储从起点到索引表示点的最大点权
- num 数组存储从起点到索引表示点有几条最短路径
- point 数组表示索引表示的点的点权

算法大致过程：

使用visted数组对点进行标号，每一次从没有标号的点中找到总边权最少的点，给予标号。

下一次循环从这个最新给予标号的点开始，探索与它联通的非标号点，进行**边的松弛**：

- 如果 weight[i] < weight[x] + route\[x][i] 的话，更新该点的总边权和点权，num[i] = num[x]；
- 如果取等号，则视情况更新点权，num[i] = num[i] + num[x]

最后输出 num[c2] 和 power[c2]

时间复杂度为 $O(N^2)$

#### 代码

```Python
# 初始化，读入数据
line = input().split(" ")
n = int(line[0])
m = int(line[1])
c1 = int(line[2])
c2 = int(line[3])
line = input().split(" ")
point = [int(x) for x in line]
route = [[0 for x in range(n)] for i in range(n)] # 二维数组，route[i][j]: i 到 j 的直接路径长度，为 0 代表无路
for x in range(m):
    line = input().split(" ")
    a = int(line[0])
    b = int(line[1])
    c = int(line[2])
    route[a][b] = c
    route[b][a] = c

visted = [0 for x in range(n)] # 记录顶点是否已被访问
weight = [float('inf') for x in range(n)] # 初始化最短路路径为最大值 inf
power = [0 for x in range(n)] # 记录起点到其他顶点的最大点权和
weight[c1] = 0 # 起点到自己路径长为 0
power[c1] = point[c1] # 起点自己的点权
visted[c1] = 1 # 起点已被访问
x = c1 # 设置起点
num = [0 for x in range(n)] # 起点到其他顶点最短路径的条数
num[c1] = 1 # 起点到起点的最短路径条数为 1

# dijkstra 算法
while visted[c2] == 0:
    for i in range(n):
        # 如果起点到 i 有边相连并且 i 未被访问
        if route[x][i] != 0 and visted[i] != 1:
            # 判断并进行边的松弛
            if weight[i] >= weight[x] + route[x][i]:
                if weight[i] == weight[x] + route[x][i]:
                    num[i] = num[i] + num[x]
                    if power[i] < power[x] + point[i]:
                        power[i] = power[x] + point[i]
                else:
                    if weight[i] > weight[x] + route[x][i]:
                        power[i] = power[x] + point[i]
                        num[i] = num[x]
                weight[i] = weight[x] + route[x][i]
    # 每一次从没有标号的点中找到总边权最少的点，给予标号
    small = sorted([weight[x] for x in range(n) if visted[x] != 1])[0]
    index = [x for x in range(n) if weight[x] == small and visted[x] != 1][0]
    visted[index] = 1
    x = index
print(num[c2], power[c2])
```

### 8. *连接所有点的最小费用

#### 题目

[LeetCode 1584. 连接所有点的最小费用](https://leetcode-cn.com/problems/min-cost-to-connect-all-points/)

#### 思路

**Prim 算法**
此算法可以称为“加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点 s 开始，逐渐长大覆盖整个连通网的所有顶点。

图的所有顶点集合为 V；初始令集合 u= {s}, v=V−u;
在两个集合 u,v 能够组成的边中，选择一条代价最小的边 ($u_0$,$v_0$) 加入到最小生成树中，并把 $v_0$ 并入到集合 u 中。
重复上述步骤，直到最小生成树有 n-1 条边或者 n 个顶点为止。


Prim算法是比较适合**稠密图**的，时间复杂度为 $(O(ElogE))$

#### 代码

```Python
class Solution:
    def minCostConnectPoints(self, points: List[List[int]]) -> int:
        from queue import PriorityQueue
        cal = lambda p1, p2: abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])  # 计算曼哈顿距离的函数

        pq = PriorityQueue()  # 优先队列（只需要知道它的作用是使最小元素在队列头）
        visit = set(range(len(points)))  # 待访问的节点集
        res = 0

        pq.put((0, 0))  # (distance, point_id)  # Prim算法从任何一个节点出发都是一样的，这里从0点开始
        while visit:  # 当没有访问完所有节点（集合不为空）
            dis, now = pq.get()  # 获取优先队列中最小的项 => (到扩展集中某最近点的距离，某最近点的序号)
            if now not in visit:  # 已访问过的直接跳过
                continue
            visit.remove(now)  # 移除出待访问的节点集
            res += dis
            for i in visit:  # 构建扩展集，就是把当前点对所有未访问点的距离都求一遍
                # 以距离为cost丢进优先队列排序就好
                pq.put((cal(points[now], points[i]), i))

        return res
```

>  注：也可以使用 kruskal 算法，需要用到 **并查集**

### 9. *Topological Order

#### 题目

[PAT 甲级 1146 Topological Order (25分)](https://pintia.cn/problem-sets/994805342720868352/problems/994805343043829760)

#### 思路

每个**拓扑排序**是这样的

- 找到一个节点，它**只作为起点**，没有被当作终点（**只有出度，没有入度**）
- **删掉这个节点，包括它相邻的所有路径**
- 然后再找一个**只作为起点没有被当作终点**的路径
- 循环往复

所以为了解决这个问题，主要有两方面

1. 如何找到只有作为起点没有把作为终点的节点？

   我们需要一个数组来记录“入度”，一个节点的入度即有多少个节点以这个节点为终点。

2. 如何删掉这个节点？

   我们对这个节点的所有目标节点，使它们的入度减一即可

##### 变量定义

- end 是一个数组，记录一个节点能通向的所有目标节点
  - 下标是id
  - 值是一个列表，存放以这个节点为起点能到达的所有目标节点
- start 是一个数组，记录入度
  - 下标是id
  - 值是入度
- ans 存放答案
- temp_start 是对 start 的拷贝，因为我们会不断修改 temp_start

##### 步骤

- 读数据
  - 起点的邻居里添加终点
  - 终点的入度加一
- 开始遍历每个查询
  - 如果输入的节点入度不是0
    - 不符合拓扑排序，加入答案列表，直接返回
  - 否则说明这个点需加入拓扑序列，将这个节点的所有目标节点入度减一

#### 代码

```Python
num_vertice, num_edge = list(map(int, input().split()))
end = [set() for _ in range(num_vertice + 1)]
start = [0 for _ in range(num_vertice + 1)]

for _ in range(num_edge):
    a, b = list(map(int, input().split()))
    end[a].add(b)
    # 记录入度
    start[b] += 1

ans = []
for i in range(int(input())):
    temp_start = start.copy() # 复制一个 start 数组
    for node in list(map(int, input().split())):
        # 入度不为 0
        if temp_start[node] != 0:
            ans.append(i)
            break
        for neighbor in end[node]:
            temp_start[neighbor] -= 1

print(" ".join(list(map(str, ans))))
```

## 字典和集合

### 1. Dangerous Goods Packaging

#### 题目

[PAT 甲级 1149 Dangerous Goods Packaging (25分)](https://pintia.cn/problem-sets/994805342720868352/problems/1038429908921778176)

#### 思路

我们需要找到给定的几个货物中，找出它们是否不互斥，使用哈希表进行判断即可。

##### 变量定义

使用danger 作为哈希表存储危险品

- 键是一个商品
- 值是一个列表，存放所有与这个危险品互为危险品的商品

由于都是整数，所以就用数组表示了

- 读取所有危险品组合
- 两个危险品都要把互相放到自己的危险品组合里
- 遍历查询的货物
  - 遍历这个货物对应的危险品
  - 如果它在货物里
  - 那就说明不能放在一起

#### 代码

```Python
num_pair, num_que = list(map(int, input().split()))
danger = [set() for i in range(100001)] # 列表中每个元素是集合，存放所有与这个危险品互为危险品的商品
for _ in range(num_pair):
    a, b = list(map(int, input().split()))
    danger[a].add(b)
    danger[b].add(a)


def judge(boat):
    for thing in boat:
        for enemy in danger[thing]: # 如果与 thing 互为危险品的 enemy 在 boat 里，说明不符合要求 
            if enemy in boat:
                return "No"
    else:
        return "Yes"


for _ in range(num_que):
    boat = set(list(map(int, input().split()[1:]))) # 每个货物组
    print(judge(boat))
```

### 2. Find Coins

#### 题目

[PAT 甲级 1048 Find Coins (25分)](https://pintia.cn/problem-sets/994805342720868352/problems/994805432256675840)

#### 思路

边读，边判断`目标和-当前数`在不在哈希集合，并最后把它放在哈希集合里。

- 读入数据
- 遍历数据
  - 如果`目标和 -当前数` 在哈希集合里，那么答案等于（`当前答案`，`目标和 - 当前数`，`当前数`）的最小值。
  - 哈希集合添加`当前数`
- 如果ans没被更新过
  - 输出无解
- 否则
  - 输出答案以及目标和减答案即可。

##### 变量定义

- _set 是一个哈希集合，存放目前已经出现过的数
- ans 是目前的匹配成功的最小值

#### 代码

```Python
num_coins, sums = list(map(int, input().split()))
_set = set()
ans = 99999 # 初始化为某个很大的数即可
num = list(map(int, input().split()))
for i in num:
    if sums - i in _set:
        ans = min(ans, sums - i, i)
    _set.add(i)
if ans != 99999:
    print(ans, sums - ans)
else:
    print("No Solution")
```

### 3. Be Unique

#### 题目

[PAT 甲级 1041 Be Unique (20分)](https://pintia.cn/problem-sets/994805342720868352/problems/994805444361437184)

#### 思路

用集合或者字典即可

##### 数据结构

- appeared 是一个哈希集合，记录已经出现过的数
- ans 是一个哈希集合，记录只出现一次的数
- a 是原数组

##### 算法

- 遍历字符串a
  - 如果这个字符没有出现过（即不在appeared里面）
    - 那么appered添加它，同时ans里也添加它
  - 如果这个字符出现过（即在appeared里面）
    - 那么ans删除它
- 如果ans长度为0
  - 输出None
- 否则
  - 再遍历字符串a
    - 找到第一个在出现在ans里面的字符
    - 输出它
- 注意，必须要有两个哈希集合，如果只用一个ans的话，如果字符出现了三次，理应是不能放在ans里的，但是如果出现一次就添加，再出现一次就抹去的话，那么出现第三次还是会被添加进去
- 注意，处理完ans后必须再来一遍遍历，不能直接输出ans的第一项，因为集合是无序的。

#### 代码

```Python
a = input().split()[1:]
appeared, ans = set(), set()
for i in a:
    if i not in appeared:
        appeared.add(i)
        ans.add(i)
    elif i in ans:
        ans.remove(i)
if len(ans) == 0:
    print("None")
else:
    for i in a:
        if i in ans:
            print(i)
            break
```

### 4. Product of Polynomials

#### 题目

[1009 Product of Polynomials (25分)](https://pintia.cn/problem-sets/994805342720868352/problems/994805509540921344)

#### 思路

先把第一个行列式存起来，读取第二个行列式的时候，对每一项，都要和第一项的每一项相乘。其中，指数相加，系数相乘。原理很简单，主要是数据结构。优雅一点可以采用字典，暴力一点可以采用数组。这题时间限制很宽松，使用数组问题不大。我对第一个行列式使用了字典，对答案使用了数组，两种都给大家cover到。

##### 变量定义

- poly 是一个字典，用以存放第一个行列式
  - 键是指数
  - 值是系数
- ans 是一个数组，用以存放答案
  - 下标代表指数
  - 值代表系数，默认是0

##### 步骤

- 对第一个行列式读取并存放到字典中
- 读取第二个行列式的每一项，将每一项都和原来的字典的每一项相乘，添加到答案中
- 输出数量和答案

#### 代码

```Python
# 变量定义
poly = dict()
ans = [0 for _ in range(2001)]

# 第一行输入
a = input().split()[1:]
i = 0
while i < len(a):
    poly[int(a[i])] = float(a[i + 1])
    i += 2
    
# 第二行输入并计算
a = input().split()[1:]
i = 0
while i < len(a):
    for j, k in poly.items():
        expo = j + int(a[i])
        coef = float(a[i + 1]) * k
        ans[expo] += coef
    i += 2

# 输出count
count = 0
for i in ans:
    if i != 0:
    	count += 1
print(count, end='')

# 输出多项式
for i in range(2000, -1, -1):
    if ans[i] != 0:
        print(" %d %.1f" % (i, ans[i]), end='')
```

### 5. *LRU 缓存机制

#### 题目

[LeetCode 146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)

#### 思路

看到题目要我们实现一个可以存储 key-value 形式数据的数据结构，并且可以记录最近访问的 key 值。首先想到的就是用字典来存储 key-value 结构，这样对于查找操作时间复杂度就是 O(1)O(1)。

但是因为字典本身是无序的，所以我们还需要一个类似于队列的结构来记录访问的先后顺序，这个队列需要支持如下几种操作：

- 在末尾加入一项
- 去除最前端一项
- 将队列中某一项移到末尾

**首先考虑列表结构**

对于列表加入有 append()，删除有 pop() 操作，这两个都是 $O(1)$ 的时间复杂度。而对于将队列中某一项移到末尾，因为列表中存储的是哈希表的 key，考虑这样一种情况：

```Python
# 操作
cache = LRUCache(4)
cache.put(3, 2)
cache.put(2, 1)
cache.put(1, 1)

# 操作之后队列：
queue = [3, 2, 1]
```

此时我们再进行 cache.put(2, 2) 的操作，因为2已经存在在哈希表中，这说明队列中已经存在值为 2 的元素，那么问题来了，如何在常数时间内把它挑出来移到队尾呢？

答案是不行，所以用列表无法实现常数时间复杂度。

**之后再考虑单链表。**

对于单链表，哈希表的结构类似于 `{key: ListNode(value)}`，即键所对应的是一个节点地址，节点的值是 value。对于链表，遇到上面那种情况时可以在常数的时间内找到对应的节点，但是如果想将它移到尾部则需要从头遍历到该节点才能保证链表不断，对于这种情况需要的时间复杂度也是 `O(n)`

为了解决移到末尾这个问题，需要使用双链表来记录，结构大概如下图所示：

![WX20190606-145838@2x.png](https://pic.leetcode-cn.com/39f4af83bbd64b0078be748474000cc99e6f488cc3f56101c2eba7d42f7321ba-WX20190606-145838@2x.png)

#### 代码

```Python
class ListNode:
    def __init__(self, key=None, value=None):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None


class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.hashmap = {}
        # 新建两个节点 head 和 tail
        self.head = ListNode()
        self.tail = ListNode()
        # 初始化链表为 head <-> tail
        self.head.next = self.tail
        self.tail.prev = self.head

    # 因为get与put操作都可能需要将双向链表中的某个节点移到末尾，所以定义一个方法
    def move_node_to_tail(self, key):
            # 先将哈希表key指向的节点拎出来，为了简洁起名node
            #      hashmap[key]                               hashmap[key]
            #           |                                          |
            #           V              -->                         V
            # prev <-> node <-> next         pre <-> next   ...   node
            node = self.hashmap[key]
            node.prev.next = node.next
            node.next.prev = node.prev
            # 之后将node插入到尾节点前
            #                 hashmap[key]                 hashmap[key]
            #                      |                            |
            #                      V        -->                 V
            # prev <-> tail  ...  node                prev <-> node <-> tail
            node.prev = self.tail.prev
            node.next = self.tail
            self.tail.prev.next = node
            self.tail.prev = node

    def get(self, key: int) -> int:
        if key in self.hashmap:
            # 如果已经在链表中了久把它移到末尾（变成最新访问的）
            self.move_node_to_tail(key)
        res = self.hashmap.get(key, -1)
        if res == -1:
            return res
        else:
            return res.value

    def put(self, key: int, value: int) -> None:
        if key in self.hashmap:
            # 如果key本身已经在哈希表中了就不需要在链表中加入新的节点
            # 但是需要更新字典该值对应节点的value
            self.hashmap[key].value = value
            # 之后将该节点移到末尾
            self.move_node_to_tail(key)
        else:
            if len(self.hashmap) == self.capacity:
                # 去掉哈希表对应项
                self.hashmap.pop(self.head.next.key)
                # 去掉最久没有被访问过的节点，即头节点之后的节点
                self.head.next = self.head.next.next
                self.head.next.prev = self.head
            # 如果不在的话就插入到尾节点前
            new = ListNode(key, value)
            self.hashmap[key] = new
            new.prev = self.tail.prev
            new.next = self.tail
            self.tail.prev.next = new
            self.tail.prev = new
```

## 排序

### 1. 数组中的第K个最大元素

#### 题目

[LeetCode 215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

#### 思路

##### 快速排序

快速排序是通常比其他*基于比较的排序算法* 效率更高，效率最好体现在大部分情况下都能达到O(nlogn)的时间复杂度。
快排的算法实现利用到了分治法（Divide and Conquer）和递归（recursive），以某个特定值为基准（pivot）将一个List分成两个子List处理。

##### 划分（Partation）

**快速排序的思路**是：

1. 在无序数组中取某个特定值为标准；
2. 从头部开始查找第一个大于*标准值*的位置（指针head）；
3. 从尾部开始查找第一个小于*标准值*的位置（指针tail）；
4. 交换两个位置的值；
5. 继续重复2和3直到head指针的位置大于等于指针tail的位置。
   这样称作快速排序的一次*划分*，*每趟划分之后都会有一个元素到达排序后最终位置*。

##### 基准关键字的选取

在当前无序区中选取划分的基准关键字（pivot）是决定算法性能的关键，通过优化pivot选取算法可以提高快速排序算法的效率。
一些算法书上给出的算法都是直接使用数组的第一个元素作为pivot，这时如果当前数组已经有序，就会出现时间复杂度为 $O(N^2)$ 的最坏情况。

###### 选第一个元素

示例代码使用方法，仅供学习，不推荐

###### 随机选取

用一个随机函数产生一个取位于 low 和 high 之间的随机数 k(low≤k≤high)，用 ls[k] 作为基准，这相当于强迫ls[low..high]中的记录是随机分布的。用此方法所得到的快速排序一般称为随机的快速排序。

> 随机选取可以大大降低快速排序出现最坏时间复杂度的情况。

###### 三者取中

另一种可行的选取办法是*三者取中*。即在当前区间里，将该区间首、尾和中间位置上的关键字比较，取三者之中值所对应的记录作为基准，在划分开始前将该基准记录和该区的最后一个元素进行交换。

> 注意：*划分*算法中pivot值和原数组中最后一个元素交换这一步非常重要，也比较容易出错。这一步即保留了pivot值，同时为后续swap提供了temp空间。

##### 快速排序的时间复杂度

因为快速排序的记录移动次数不大于比较的次数，所以快速排序中的基本操作就是*比较*，时间复杂度也关注*比较*的次数。

##### 最坏的时间复杂度

最坏的时间复杂度发生在：每次划分选取的基准都是当前无序区中关键字最小(或最大)的记录，划分的结果是基准左边的子区间为空(或右边的子区间为空)，而划分所得的另一个非空的子区间中记录数目，仅仅比划分前的无序区中记录个数减少一个。此时，快速排序必须做 `n-1` 次划分，第i次划分开始时区间长度为 `n-i+1`，所需的比较次数为 `n-i(1≤i≤n-1)`，故总的比较次数达到最大值：`Cmax = n(n-1)/2=O(n2)`。
比如上面描述的如果选取第一个元素为pivot，并且该数组为有序数组就会出现最坏情况。

##### 最好的时间复杂度

快速排序最好和平均时间复杂度都为 $O(nlogn)$。
在最好情况下，每次划分所取的基准都是当前无序区的"中值"记录，划分的结果是基准的左、右两个无序子区间的长度大致相等。
用递归树来分析最好情况下的比较次数更简单。因为每次划分后左、右子区间长度大致相等，故递归树的高度为 $O(logn)$，而递归树每一层上各结点所对应的划分过程中所需要的关键字比较次数总和不超过n，故整个排序过程所需要的关键字比较总次数 $C(n)=O(nlogn)$。

##### 快速排序的稳定性

快速排序*是不稳定的*排序算法，即`当关键字K1 == K2时，如果R1在R2之前，采用快速排序后无法确定R1R2的顺序`。
关于我们讨论算法稳定性的意义再多说几句。

> 以下引用自[维基百科 - 排序算法](https://zh.wikipedia.org/wiki/排序算法#.E7.A9.A9.E5.AE.9A.E6.80.A7)
> 当相等的元素是无法分辨的，比如像是整数，稳定性并不是一个问题。然而，假设以下的数对将要以他们的第一个数字来排序。
> (4, 1) (3, 1) (3, 7)（5, 6）
> 在这个状况下，有可能产生两种不同的结果，一个是让相等键值的纪录维持相对的次序，而另外一个则没有：
> (3, 1) (3, 7) (4, 1) (5, 6) （維持次序）
> (3, 7) (3, 1) (4, 1) (5, 6) （次序被改变）
> 不稳定排序算法可能会在相等的键值中改变纪录的相对次序，但是稳定排序算法从来不会如此。不稳定排序算法可以被特别地实现为稳定。作这件事情的一个方式是人工扩充键值的比较，如此在其他方面相同键值的两个对象间之比较，（比如上面的比较中加入第二个标准：第二个键值的大小）就会被决定使用在原先数据次序中的条目，当作一个同分决赛。然而，要记住这种次序通常牵涉到额外的空间负担。
> 典型的例子就是在基数排序中，即我们要*对多个关键词多次排序的时候，就一定要使用稳定算法*。

#### 代码

```Python
class Solution:
    def quick_sort(self, ls, left, right):
        if left >= right:
            return
        pivot = ls[left]
        i, j = left, right
        while True:
            # 从尾部开始查找第一个小于标准值的位置
            while i < j and ls[j] > pivot:
                j -= 1
            # 头尾指针相遇，循环结束
            if i == j:
                break
            else:
                # 交换两个位置的值并移动指针
                ls[i] = ls[j]
                i += 1
            # 从头部开始查找第一个大于标准值的位置
            while i < j and ls[i] < pivot:
                i += 1
            if i == j:
                break
            else:
                # 交换两个位置的值并移动指针
                ls[j] = ls[i]
                j -= 1
        ls[i] = pivot
        self.quick_sort(ls, left, i-1)
        self.quick_sort(ls, i+1, right)

    def findKthLargest(self, nums: List[int], k: int) -> int:
        self.quick_sort(nums, 0, len(nums)-1)
        return nums[len(nums) - k]
```

### 2. Quick Sort

#### 题目

[PAT 甲级 **1101** Quick Sort (25分)](https://pintia.cn/problem-sets/994805342720868352/problems/994805366343188480)

#### 思路

这道题有很多方法

- 有一种方法是，pivot必须在它排好序的位置上
  - 那么就需要对原数排序，找两个序列下标相同的那些项
  - 但是有些数在自己应该在的位置，但是左边有比它大的，右边有比它小的
  - 那这样又要频繁使用`MIN()`函数
  - 加上排序，这样会导致复杂度比较大，不建议使用
- 还有一种方法是运用**线性扫描**的思想
  - 设两个变量为左边最大和右边最小，初始化为`nums[0]`和`min(nums)`
  - 遍历num
  - 每遇到一个数
    - 如果在左边最大和右边最小之间的
      - 添加进答案
      - 同时更新左边最大为它
    - 如果是等于右边最小的
      - 右边最小等于剩下的数的右边最小
  - 这个方法前面都很美好但是最后一步又是需要频繁调用`Min()`函数，复杂度依然不小

所以我推荐我的方法，是第二种方法的改良。它的复杂度是三次$O(N)$，也就是$O(N)$

- **首先开一个left数组，意义是，到第i个数的时候，左边所有数的最大值。**
- 遍历一遍原数组更新left
- **开一个right数组，意义是，到第i个数的时候，右边所有数的最小值。**
- 遍历一遍原数组更新right
- 再遍历一遍原数组，如果一个数下标为`i`，当`left[i] <= nums[i] <= right[i]`的时候，把它添加进答案里
- 输出即可。

注：Python 大概三次里面会有一次超时，不必紧张，重复提交几次即可。

#### 代码

```Python
n = int(input())
nums = list(map(int, input().split()))
# 找每个数左边的最大值
left = [nums[0] for _ in range(n)]
for i in range(1, n):
    left[i] = nums[i] if nums[i] > left[i - 1] else left[i - 1]
# 找每个数右边的最小值
right = [nums[-1] for _ in range(n)]
for i in range(n - 2, -1, -1):
    right[i] = nums[i] if nums[i] < right[i + 1] else right[i + 1]
# 输出
count = [j for i, j in enumerate(nums) if left[i] <= j <= right[i]]
print(len(count))
print(" ".join(list(map(str, count))))
```

## 贪心算法

### 1. Chain the Ropes

#### 题目

[PAT 甲级 1125 Chain the Ropes (25分)](https://pintia.cn/problem-sets/994805342720868352/problems/994805350316752896)

#### 思路

这题最困难的是理解题意。题目的意思是，总共Ｎ个绳子，把它们连接在一起，每次连接两根绳子，连起来的长度是总绳子长度的一遍，然后两根合二为一，总之就是两根绳子合并成一根，合并后的长度为他俩的平均数，求最长的连接方式。

**贪心思想：**

- 假设以一个节点为起点，不断向后连接绳子，那么这个节点的长度在总长度里会不断地除以２除以２除以２
- 相反这样的话最后一个节点只会被除以１次２
- 所以我们可以将所有绳子排序，然后**从头开始连接，这样最长的被除以２的次数是最少的，那么最长也是最大的**。

#### 代码

```Python
n = int(input())
ropes = sorted(list(map(int, input().split())))
length = (ropes[0] + ropes[1]) / 2
for i in range(2,n):
    length = (length + ropes[i])/2
print(int(length))
```

### 2. Mooncake

#### 题目

[PAT 甲级 1070 Mooncake (25分)](https://pintia.cn/problem-sets/994805342720868352/problems/994805399578853376)

#### 思路

题目的意思很简单，给你几种蛋糕的库存和总价，以及市场上需要的总蛋糕量，去计算能获得的最大收益。唯一一个坑点是库存也可以是小数。

我们只要把蛋糕按照单位价格最高的排序，然后遍历蛋糕，将需求不断用前面的蛋糕填满，计算价格就可以了。

##### 变量定义

- kinds 是月饼种类数量
- demands是总需求
- storage 是各个月饼的库存
- prices 是各个月饼的总价
- cakes 是一个元组列表，每一项是一个月饼元组，包含
  - 库存
  - 总价
- profits 总利润

##### 步骤

- 读取信息
- 将cakes用storage和prices组合起来
- 按照**单价**从高到低排列月饼
- 遍历月饼
- 只要需求大于这个月饼的库存
- 那么就当作这个月饼全被买了，更新demands和profits
- 否则，将剩下的需求用库存填补，相应利润增加(demands/storage) * 总价
- 输出利润即可。

#### 代码

```Python
kinds, demands = list(map(int, input().split()))
storages = list(map(float, input().split()))
prices = list(map(float, input().split()))
# x[1]/x[0]: 总价格 / 数量
cakes = sorted([(i, j) for i, j in zip(storages, prices)], key=lambda x: x[1]/x[0], reverse=True)
profits = 0
for storage, price in cakes:
    if demands > storage:
        demands -= storage
        profits += price
    elif demands <= storage:
        profits += (demands / storage) * price
        break
print("{:.2f}".format(profits))
```

### 3. Magic Coupon

#### 题目

[PAT 甲级 1037 Magic Coupon (25分)](https://pintia.cn/problem-sets/994805342720868352/problems/994805451374313472)

#### 思路

题目说了一大堆，其实题目无非就是：给你两个序列，从第一个序列挑数乘以第二序列挑一个数，使这些乘积最大。

**数选了一次就不能选，但是可以一次都不选**。

因为**正的越大乘以正的越大，效果越好，负的越大乘以负的越大效果越好**，而一正一负就不乘了。那我们把两个序列按照正负分为四个序列，一正一负二正二负，同时排序。利用zip和sum，对两个正序列的值相乘，对两个负序列的值相乘，并加起来。

##### 变量定义

- a 是第一个序列
- a_pos 是第一个序列的正数
- a_neg 是第一个序列的负数
- b 是第一个序列
- b_pos 是第一个序列的正数
- b_neg 是第一个序列的负数

##### 步骤

- 对a_pos,b_pos按从大到小排序
- 对a_neg,b_neg按从小到大排序
- 将a_pos,b_pos用zip组合起来，对组合起来的每一项，求它们的乘积，并把所有乘积加起来。
- 对a_neg,b_neg同理

#### 代码

```Python
num_a = int(input())
a = list(map(int, input().split()))
a_pos = sorted([i for i in a if i > 0], reverse=True) # 正数从大到小排序
a_neg = sorted([i for i in a if i < 0]) # 负数从小到大排序
num_b = int(input())
b = list(map(int, input().split()))
b_pos = sorted([i for i in b if i > 0], reverse=True) # 正数从大到小排序
b_neg = sorted([i for i in b if i < 0]) # 负数从小到大排序
print(sum([i * j for i, j in zip(a_pos, b_pos)]) + sum([i * j for i, j in zip(a_neg, b_neg)]))
```

### 4. 无重叠区间

#### 题目

[LeetCode 435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)

#### 思路

选择区间组成无重叠区间，**为使区间数量尽可能多，被选区间的右端点应尽可能小，留给后面的区间的空间就大，那么后面能够选择的区间个数也就大**。因此可以先对区间列表**根据右端点排序**，遍历新的列表，根据是否重叠决定是否移除区间。

#### 代码

```Python
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        if intervals == []: return 0
        ## 根据区间右端点排序
        intervals = sorted(intervals, key = lambda x: x[1])
        num = 0
        new_interval = intervals[0]     # 被选的最新区间
        for interval in intervals[1:]:
            if interval[0] < new_interval[1]:   # 如果重叠删除区间，删除数量+1
                num += 1
            else:   # 如果不重叠更新new_interval
                new_interval = interval
        return num
```

### 5. 用最少数量的箭引爆气球

#### 题目

[LeetCode 452. 用最少数量的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)

#### 思路

> 就是上面 4. 无重叠区间 的变式！

我们首先随机地射出一支箭，再看一看是否能够调整这支箭地射出位置，使得我们可以引爆更多数目的气球。

![fig1](https://assets.leetcode-cn.com/solution-static/452/1.png)

如图 1-1 所示，我们随机射出一支箭，引爆了除红色气球以外的所有气球。我们称所有引爆的气球为「原本引爆的气球」，其余的气球为「原本完好的气球」。可以发现，如果我们将这支箭的射出位置稍微往右移动一点，那么我们就有机会引爆红色气球，如图 1-2 所示。

那么我们最远可以将这支箭往右移动多远呢？我们唯一的要求就是：原本引爆的气球只要仍然被引爆就行了。这样一来，我们找出原本引爆的气球中右边界位置最靠左的那一个，将这支箭的射出位置移动到这个右边界位置，这也是最远可以往右移动到的位置：如图 1-3 所示，只要我们再往右移动一点点，这个气球就无法被引爆了。

为什么「原本引爆的气球仍然被引爆」是唯一的要求？别急，往下看就能看到其精妙所在。

因此，我们可以断定：

一定存在一种最优（射出的箭数最小）的方法，使得每一支箭的射出位置都恰好对应着某一个气球的右边界。

这是为什么？我们考虑任意一种最优的方法，对于其中的任意一支箭，我们都通过上面描述的方法，将这支箭的位置移动到它对应的「原本引爆的气球中最靠左的右边界位置」，那么这些原本引爆的气球仍然被引爆。这样一来，所有的气球仍然都会被引爆，并且每一支箭的射出位置都恰好位于某一个气球的右边界了。

有了这样一个有用的断定，我们就可以快速得到一种最优的方法了。考虑所有气球中右边界位置最靠左的那一个，那么一定有一支箭的射出位置就是它的右边界（否则就没有箭可以将其引爆了）。当我们确定了一支箭之后，我们就可以将这支箭引爆的所有气球移除，并从剩下未被引爆的气球中，再选择右边界位置最靠左的那一个，确定下一支箭，直到所有的气球都被引爆。

我们可以写出如下的伪代码：

```
let points := [[x(0), y(0)], [x(1), y(1)], ... [x(n-1), y(n-1)]]，表示 n 个气球
let burst := [false] * n，表示每个气球是否被引爆
let ans := 0，表示射出的箭数

将 points 按照 y 值（右边界）进行升序排序

while burst 中还有 false 值 do
    let i := 最小的满足 burst[i] = false 的索引 i
    for j := i to n-1 do
        if x(j) <= y(i) then
            burst[j] := true
        end if
    end for
end while

return ans
```

这样的做法在最坏情况下时间复杂度是 $O(n^2)$，即这 $n$ 个气球对应的区间互不重叠，$while$ 循环需要执行 $n$ 次。那么我们如何继续进行优化呢？

事实上，在内层的 $j$ 循环中，当我们遇到第一个不满足 $x(j)≤y(i)$ 的 $j$ 值，就可以直接跳出循环，并且这个 $y(j)$ 就是下一支箭的射出位置。为什么这样做是对的呢？我们考虑某一支箭的索引 $i_t$ 以及它的下一支箭的索引 $j_t$，对于索引在 $j_t$ 之后的任意一个可以被 $i_t$ 引爆的气球，记索引为 $j_0$，有：$x(j_0) \leq y(i_t)$

由于 $y(i_t) \leq y(j_t)$显然成立，那么 $x(j_0) \leq y(j_t)$ 也成立，也就是说：当前这支箭在索引 $j_t$（第一个无法引爆的气球）之后所有可以引爆的气球，下一支箭也都可以引爆。因此我们就证明了其正确性，也就可以写出如下的伪代码：

```
let points := [[x(0), y(0)], [x(1), y(1)], ... [x(n-1), y(n-1)]]，表示 n 个气球
let pos := y(0)，表示当前箭的射出位置
let ans := 0，表示射出的箭数

将 points 按照 y 值（右边界）进行升序排序

for i := 1 to n-1 do
    if x(i) > pos then
        ans := ans + 1
        pos := y(i)
    end if
end for

return ans
```

这样就可以将计算答案的时间从 $O(n^2)$ 降低至 $O(n)$。

**复杂度分析**

时间复杂度：$O(nlogn)$，其中 $n$ 是数组 $points$ 的长度。排序的时间复杂度为 $O(nlogn)$，对所有气球进行遍历并计算答案的时间复杂度为 $O(n)$，其在渐进意义下小于前者，因此可以忽略。

空间复杂度：$O(logn)$，即为排序需要使用的栈空间。

#### 代码

```Python
class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        if not points:
            return 0
        
        points.sort(key=lambda balloon: balloon[1])
        pos = points[0][1]
        ans = 1
        for balloon in points:
            if balloon[0] > pos:
                pos = balloon[1]
                ans += 1
        
        return ans
```
